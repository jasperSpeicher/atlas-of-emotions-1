#actions {
	position: absolute;
	width: 100%;
	height: 100%;
	min-height: 600px;

	top: 0;
	left: 50%;
	margin-left: -50%;

	text-align: center;
	pointer-events: none;

	transition-property: top, transform;
	transition-duration: #{$states-backgrounded-duration-in}s;
	transition-timing-function: cubic-bezier(.81,.34,.63,.85);

	&.backgrounded {
		transform: translateY(#{$actions-margins-bottom}px) scale($actions-backgrounded-scale);

		&.triggers {

			// same math as in .actions-container below,
			// but subtracted from total viewport height
			// to push .actions-containers to bottom.
			top: calc((100% - (
					(100% + #{$states-backgrounded-top}) -
					(100% * (1 - #{$states-backgrounded-scale}) / 2) -
					#{$states-backgrounded-scale} * (#{$states-containers-bottom} + 50px)
				) - 20%);
		}
	}

	.label-valence {
		display: inline-block;
		position: relative;
		top: 0.1em;
		// right: 0.1em;
		padding-right: 0.2em;

		font-family: 'Raleway', sans-serif;
		font-weight: 700;
		font-size: 150%;
		letter-spacing: -0.15em;

		&.plus,
		&.minus {
			font-size: 180%;
		}
		&.plus {
			top: 0.15em;
		}
	}
	.short-slash {
		display: inline-block;
		margin: 0 0.1em;
		font-size: 75%;
	}

	.actions-container {
		position: absolute;
		width: 100%;
		height: 100%;

		// align top of actions containers with bottom of
		// 'backgrounded' states graph, which is scaled and translated.
		// this math is basically:
		// (states position) - (scaled states offset) - scale * (states graph offset from parent + states graph bottom margin)
		top: calc((100% + #{$states-backgrounded-top}) -
			(100% * (1 - #{$states-backgrounded-scale}) / 2) -
			#{$states-backgrounded-scale} * (#{$states-containers-bottom} + 50px));
		left: 50%;

		pointer-events: none;
		opacity: 0.0;

		&.transitioning {
			transition-property: transform, opacity;
			transition-duration: #{$emotions-panX-duration}s;
			transition-timing-function: ease-in-out, cubic-bezier(0.9, 0.0, 0.5, 1.0);
		}

		&.active {
			pointer-events: auto;
			opacity: 1.0;
		}
	}

	.graph-container,
	.label-container {
		position: absolute;
		top: 0;
		left: 0;
	}

	.graph-container {
		width: $actions-graph-width;
		height: 40%;
		margin-left: -$actions-graph-width/2;
		transform-origin: top;
		transform: rotateX(60deg);

		// pointer-events: auto;

		.valence {
			stroke: rgba(77, 77, 77, 0.25);
			stroke-width: 1;
			cursor: pointer;

			&.constructive {
				fill: rgba(255, 255, 255, 0.25);
			}
			&.both {
				fill: rgba(255, 255, 255, 0.0);
			}
			&.destructive {
				fill: rgba(77, 77, 77, 0.1);
			}
			&.none {
				display: none;
			}

			&.highlighted {
				stroke: rgba(33, 33, 33, 0.25);
				stroke-width: 2;
			}

		}
	}

	.label-container {
		// pointer-events: none;
		// transform: scaleY(0.578);	// 1/sqrt(3), using scale to equate to rotateX(60deg)

		.label {
			position: absolute;
			bottom: 0;
			transform-origin: bottom;

			@include emotion-color;
			white-space: nowrap;

			// cursor: pointer;
			// pointer-events: auto;

			div {
				position: absolute;
				margin-left: -60px;		// TODO: where does this magic number come from?
										// needed to align with arrow points.
				h3 {
					// transform: rotateX(-60deg);
					// transform: scaleY(1.73);	// sqrt(3), using scale to equate to rotateX(60deg)
												// set by d3 instead, since d3 is applying another transform already
					margin: 0;
					line-height: 1em;
					cursor: pointer;
				}
			}
		}

		&.active h3 {
			pointer-events: auto;
		}

	}
}

.action-arrow {
	stroke: none;
	cursor: pointer;
	path {
		mix-blend-mode: multiply;
	}
}

#temp-actions-nav {
	position: absolute;
	height: 100%;
	right: 3%;
	pointer-events: none;

	.prev {
		position: absolute;
		top: 3%;
		right: 0;
		pointer-events: auto;
		white-space: nowrap;
	}

	.next {
		position: absolute;
		bottom: 3%;
		right: 0;
		pointer-events: auto;
		white-space: nowrap;
	}

	opacity: 0.0;
	-webkit-transition: opacity 1s;
	transition:         opacity 1s;
	&.visible {
		opacity: 1.0;
	}
}